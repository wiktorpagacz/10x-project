/**
 * OpenRouter AI Service
 * Encapsulates logic for interacting with the OpenRouter.ai API.
 * Handles request construction, API key management, and response parsing.
 */

/**
 * Represents a flashcard suggestion generated by the AI.
 */
export interface GeneratedFlashcard {
  front: string;
  back: string;
}

/**
 * Response from the OpenRouter API.
 */
interface OpenRouterResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

/**
 * Error thrown when the OpenRouter API call fails.
 */
export class OpenRouterError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
  ) {
    super(message);
    this.name = 'OpenRouterError';
  }
}

/**
 * Calls the OpenRouter API to generate flashcard suggestions.
 *
 * @param sourceText - The source text from which to generate flashcards
 * @returns An array of generated flashcard suggestions
 * @throws OpenRouterError if the API call fails
 */
export async function generateFlashcards(
  sourceText: string,
): Promise<GeneratedFlashcard[]> {
  const apiKey = import.meta.env.OPENROUTER_API_KEY;

  if (!apiKey) {
    throw new OpenRouterError(
      500,
      'MISSING_CONFIG',
      'OpenRouter API key is not configured',
    );
  }

  const systemPrompt = `You are an expert flashcard generator. Your task is to create high-quality flashcard questions and answers based on provided source material.

Requirements:
- Generate between 3-10 flashcard pairs
- Each question (front) should be clear, concise, and testable
- Each answer (back) should be accurate and comprehensive but concise
- Avoid trivial or obvious questions
- Ensure questions promote understanding and retention
- Return ONLY valid JSON array of objects with "front" and "back" properties

Format your response as a JSON array like this:
[
  { "front": "question 1?", "back": "answer 1" },
  { "front": "question 2?", "back": "answer 2" }
]`;

  const userPrompt = `Generate flashcards from this source material:\n\n${sourceText}`;

  try {
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'openai/gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: systemPrompt,
          },
          {
            role: 'user',
            content: userPrompt,
          },
        ],
        temperature: 0.7,
        max_tokens: 2000,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMessage =
        errorData?.error?.message || `HTTP ${response.status}`;

      throw new OpenRouterError(
        response.status,
        errorData?.error?.code || 'API_ERROR',
        errorMessage,
      );
    }

    const data = (await response.json()) as OpenRouterResponse;

    if (!data.choices?.[0]?.message?.content) {
      throw new OpenRouterError(
        500,
        'INVALID_RESPONSE',
        'Unexpected response format from OpenRouter',
      );
    }

    const content = data.choices[0].message.content.trim();

    // Extract JSON from the response (in case there's extra text)
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      throw new OpenRouterError(
        500,
        'PARSE_ERROR',
        'Failed to extract JSON from AI response',
      );
    }

    const flashcards = JSON.parse(jsonMatch[0]) as GeneratedFlashcard[];

    // Validate flashcard structure
    if (
      !Array.isArray(flashcards) ||
      !flashcards.every(
        (fc) =>
          typeof fc.front === 'string' &&
          typeof fc.back === 'string' &&
          fc.front.length > 0 &&
          fc.back.length > 0,
      )
    ) {
      throw new OpenRouterError(
        500,
        'INVALID_FLASHCARDS',
        'Generated flashcards do not meet validation requirements',
      );
    }

    return flashcards;
  } catch (error) {
    // Re-throw OpenRouterError instances
    if (error instanceof OpenRouterError) {
      throw error;
    }

    // Wrap other errors
    if (error instanceof Error) {
      throw new OpenRouterError(
        500,
        'NETWORK_ERROR',
        `Failed to call OpenRouter API: ${error.message}`,
      );
    }

    throw new OpenRouterError(
      500,
      'UNKNOWN_ERROR',
      'An unknown error occurred while calling OpenRouter API',
    );
  }
}
