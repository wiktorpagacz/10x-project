# API Endpoint Implementation Plan: POST /flashcards/batch

## 1. Endpoint Overview

The `POST /flashcards/batch` endpoint enables authenticated users to create multiple flashcards in a single request. This endpoint is invoked after a user reviews AI-generated flashcard suggestions from a generation session. The endpoint accepts a batch of flashcards with metadata about their origin (AI-generated, AI-edited, or manually created), persists them to the database, and returns the newly created flashcard objects.

**Purpose**: Streamline the workflow of accepting and storing reviewed AI suggestions while maintaining full audit trail through the `source` and `generation_id` fields.

---

## 2. Request Details

- **HTTP Method**: `POST`
- **URL Structure**: `/api/flashcards/batch`
- **File Path**: `src/pages/api/flashcards/batch.ts`
- **Request Body**: JSON object conforming to the `CreateFlashcardsBatchCommand` type.

### Parameters

#### Required Parameters
- **`generation_id`** (number): The ID of the generation session that produced the flashcard suggestions. Must be a positive integer and must reference a generation record owned by the authenticated user.
- **`flashcards`** (array): A non-empty array of flashcard objects to create. Maximum 100 items per request to prevent payload abuse.
  - **`front`** (string): The question or prompt side of the flashcard. Must be 1–200 characters.
  - **`back`** (string): The answer side of the flashcard. Must be 1–500 characters.
  - **`source`** (string): Indicates the origin of the flashcard. Must be one of:
    - `"ai-full"`: Generated by AI and accepted without edits.
    - `"ai-edited"`: Generated by AI and edited by the user before saving.
    - `"manual"`: Created manually by the user.

#### Example Request
```json
{
  "generation_id": 123,
  "flashcards": [
    {
      "front": "What is photosynthesis?",
      "back": "The process by which plants convert light energy into chemical energy.",
      "source": "ai-full"
    },
    {
      "front": "Why do leaves appear green?",
      "back": "Because chlorophyll absorbs red and blue light but reflects green light.",
      "source": "ai-edited"
    }
  ]
}
```

---

## 3. Used Types

The implementation will use the following types defined in `src/types.ts`:

- **Command Model**: `CreateFlashcardsBatchCommand` — Validates the request structure and constrains the payload.
- **Component Type**: `BatchCreateFlashcardItem` — Represents a single flashcard within the batch.
- **Enum Type**: `FlashcardSource` — Enforces the allowed values for the `source` field ('ai-full' | 'ai-edited' | 'manual').
- **Output DTO**: `FlashcardDto` — The public-facing representation of a created flashcard, excluding sensitive fields like `user_id` and `fts_vector`.

---

## 4. Response Details

### Success Response (201 Created)

**Condition**: The request is valid, all flashcards pass validation, and the database insertion is successful.

**Payload**: An array of `FlashcardDto` objects representing the newly created flashcards. The array will contain flashcards in the same order as the request.

**Example Response**:
```json
[
  {
    "id": 1001,
    "generation_id": 123,
    "front": "What is photosynthesis?",
    "back": "The process by which plants convert light energy into chemical energy.",
    "source": "ai-full",
    "created_at": "2026-01-05T10:30:00Z",
    "updated_at": "2026-01-05T10:30:00Z"
  },
  {
    "id": 1002,
    "generation_id": 123,
    "front": "Why do leaves appear green?",
    "back": "Because chlorophyll absorbs red and blue light but reflects green light.",
    "source": "ai-edited",
    "created_at": "2026-01-05T10:30:00Z",
    "updated_at": "2026-01-05T10:30:00Z"
  }
]
```

### Error Responses

- **400 Bad Request**:
  - Invalid JSON payload structure.
  - Missing required fields (`generation_id`, `flashcards`, or flashcard properties).
  - `generation_id` is not a positive integer.
  - `flashcards` is not an array or is empty.
  - A flashcard's `front` field is missing, empty, or exceeds 200 characters.
  - A flashcard's `back` field is missing, empty, or exceeds 500 characters.
  - A flashcard's `source` field is missing or not one of the allowed values.
  - The `flashcards` array exceeds the maximum size (100 items).

- **401 Unauthorized**:
  - The request lacks a valid authentication session.

- **403 Forbidden**:
  - The `generation_id` does not exist or does not belong to the authenticated user.

- **500 Internal Server Error**:
  - A database error occurs during insertion (e.g., connection failure, constraint violation).
  - An unexpected server-side error occurs.

---

## 5. Data Flow

1. A `POST` request is made to `/api/flashcards/batch` with a JSON body.
2. Astro middleware verifies the user's session. If invalid or missing, the request is rejected with a `401` status.
3. The `POST` handler in `src/pages/api/flashcards/batch.ts` is executed.
4. The handler retrieves the Supabase client and user ID from `Astro.locals`.
5. The handler parses and validates the request body using a Zod schema based on `CreateFlashcardsBatchCommand`. If validation fails, a `400` response is returned with detailed error information.
6. The handler retrieves the generation record from the database to verify it exists and belongs to the authenticated user.
   - If the record is not found or does not belong to the user, a `403 Forbidden` response is returned.
7. The handler calls the `flashcardService.createBatch()` method, passing:
   - The Supabase client
   - The authenticated user's ID
   - The validated batch data (`generation_id` and `flashcards` array)
8. **Inside `flashcardService.createBatch()`**:
   - The service constructs an insert payload for the `flashcards` table.
   - For each flashcard in the batch, it adds:
     - `user_id` (from the authenticated user)
     - `generation_id` (from the request)
     - `front`, `back`, `source` (from the request)
     - `created_at` and `updated_at` are automatically set by the database.
   - The service calls `supabase.from('flashcards').insert(payload).select()` to insert all records and retrieve them in a single operation.
   - If the insertion succeeds, the service transforms the returned records into `FlashcardDto` objects (excluding `user_id` and `fts_vector`) and returns the array.
   - If a database error occurs (e.g., foreign key constraint violation), the service throws an error with appropriate context.
9. The API handler receives the array of `FlashcardDto` objects from the service.
10. The API handler returns a `201 Created` response with the array of newly created flashcards as the JSON body.
11. In the `catch` block, if any error occurs, it is logged with context (user ID, batch size, error details), and a generic `500 Internal Server Error` response is returned to the client.

---

## 6. Security Considerations

### Authentication
- The endpoint is protected by Astro middleware that verifies the user's session. Only authenticated requests are processed.
- The `user_id` is always derived from `Astro.locals.session`, ensuring that flashcards are always associated with the authenticated user, never a user-specified value.

### Authorization
- Before processing the batch, the handler verifies that the `generation_id` belongs to the authenticated user by querying the `generations` table. This prevents users from creating flashcards linked to other users' generation sessions.
- Supabase Row-Level Security (RLS) policies on the `flashcards` and `generations` tables provide an additional layer of protection at the database level.

### Input Validation
- A Zod schema enforces strict validation of the request payload:
  - `generation_id` must be a positive integer.
  - `flashcards` must be a non-empty array with a maximum of 100 items.
  - Each flashcard's `front` must be 1–200 characters.
  - Each flashcard's `back` must be 1–500 characters.
  - Each flashcard's `source` must be one of the allowed enum values.
- Validation happens before any database operations, preventing invalid data from reaching the database.

### Data Integrity
- The `generation_id` foreign key constraint at the database level ensures referential integrity. If a generation record is deleted, all linked flashcards are automatically cleaned up (via `ON DELETE CASCADE` or similar mechanism, depending on the actual schema).
- String length validation via Zod is enforced before insertion, preventing database constraint violations.

### Rate Limiting
- If rate limiting has been implemented in the Astro middleware for the `POST /api/generations` endpoint, it should also apply to `POST /api/flashcards/batch`. Consider adding or updating the rate-limiting configuration to include this endpoint (e.g., 10 requests per user per minute).

### Payload Size
- The Zod schema enforces a maximum array size (100 flashcards) to prevent excessively large payloads that could consume server resources.

---

## 7. Error Handling

### Validation Errors (400 Bad Request)
**Scenario**: The request payload fails Zod validation.
- **Cause**: Invalid JSON, missing fields, incorrect field types, or values outside allowed ranges.
- **Handling**:
  1. Catch the Zod validation error.
  2. Extract user-friendly error details from the validation error.
  3. Return a `400 Bad Request` response with a JSON body containing the validation errors.
  4. Log the error for debugging (with non-sensitive details).

**Example Error Response**:
```json
{
  "error": "Validation failed",
  "details": [
    {
      "path": "flashcards[0].front",
      "message": "String must contain at most 200 character(s)"
    },
    {
      "path": "flashcards[1].source",
      "message": "Invalid enum value. Expected 'ai-full' | 'ai-edited' | 'manual'"
    }
  ]
}
```

### Generation Not Found or Unauthorized (403 Forbidden)
**Scenario**: The `generation_id` does not exist or does not belong to the authenticated user.
- **Cause**: User provides an invalid or non-owned generation ID.
- **Handling**:
  1. Query the `generations` table for the provided `generation_id` and authenticated `user_id`.
  2. If no record is found, return a `403 Forbidden` response.
  3. Log the attempt with the user ID and generation ID for security monitoring.

**Example Error Response**:
```json
{
  "error": "Generation not found or access denied"
}
```

### Database Errors (500 Internal Server Error)
**Scenario**: An unexpected database error occurs during insertion.
- **Cause**: Connection failure, constraint violation (e.g., foreign key), disk full, or other database-level issues.
- **Handling**:
  1. Catch the database error in the `catch` block.
  2. Log the full error details with context (user ID, batch size, operation details) for debugging.
  3. Return a generic `500 Internal Server Error` response to the client (do not expose internal error details).

**Example Error Response**:
```json
{
  "error": "An internal server error occurred. Please try again later."
}
```

### Unauthorized (401 Unauthorized)
**Scenario**: The request lacks a valid authentication session.
- **Cause**: No session cookie, expired token, or invalid token.
- **Handling**: Astro middleware intercepts the request and returns a `401` before the handler is invoked.

---

## 8. Performance Considerations

### Primary Bottleneck
The main performance factor is the database insertion operation. However, this is highly optimized:
- **Batch Insert**: Supabase's `.insert()` method accepts an array of objects and performs a bulk insert in a single database transaction, minimizing round-trips.
- **Single Select**: Using `.insert(...).select()` retrieves the inserted records in the same operation, avoiding an additional query.
- **Indexing**: The `user_id` index on the `flashcards` table supports fast lookups and insertions.

### Expected Performance
- **Typical request (10 flashcards)**: < 500 ms (depending on network latency and database load).
- **Maximum request (100 flashcards)**: < 1 second.

### Optimization Strategies
1. **Batch Size Limit**: Enforcing a maximum of 100 flashcards per request prevents excessively long transaction times.
2. **Connection Pooling**: Supabase provides connection pooling, ensuring efficient use of database connections.
3. **Caching**: If generation metadata is accessed frequently, consider caching generation records for a short duration (e.g., 5 minutes) to reduce database queries. However, this is likely not necessary for this endpoint.

### Monitoring Recommendations
- Monitor the response time of the endpoint under typical load.
- Log database query times to identify potential bottlenecks.
- Alert if insertion operations exceed 2 seconds (indicating database congestion or other issues).

---

## 9. Implementation Steps

### Step 1: Define Validation Schema
In `src/pages/api/flashcards/batch.ts`, create a Zod schema for the `CreateFlashcardsBatchCommand`:

```typescript
import { z } from 'zod';

const createFlashcardsBatchSchema = z.object({
  generation_id: z.number().int().positive(),
  flashcards: z.array(
    z.object({
      front: z.string().min(1).max(200),
      back: z.string().min(1).max(500),
      source: z.enum(['ai-full', 'ai-edited', 'manual']),
    }),
    { message: 'Flashcards must be a non-empty array' }
  ).min(1).max(100),
});
```

### Step 2: Create Flashcard Service
Create a new file `src/lib/services/flashcardService.ts` with the following structure:

```typescript
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from 'src/db/database.types';
import type { FlashcardDto } from 'src/types';

export async function createBatch(
  supabase: SupabaseClient<Database>,
  userId: string,
  generationId: number,
  flashcards: Array<{ front: string; back: string; source: string }>
): Promise<FlashcardDto[]> {
  // Implementation details in the following step
}
```

### Step 3: Implement Core Service Logic
Inside `flashcardService.ts`, implement the `createBatch` function:

```typescript
export async function createBatch(
  supabase: SupabaseClient<Database>,
  userId: string,
  generationId: number,
  flashcards: Array<{ front: string; back: string; source: string }>
): Promise<FlashcardDto[]> {
  // Construct the insert payload
  const insertPayload = flashcards.map((fc) => ({
    user_id: userId,
    generation_id: generationId,
    front: fc.front,
    back: fc.back,
    source: fc.source,
  }));

  // Insert and retrieve the created records
  const { data, error } = await supabase
    .from('flashcards')
    .insert(insertPayload)
    .select();

  if (error) {
    throw new Error(`Failed to create flashcards: ${error.message}`);
  }

  // Transform to DTO (exclude user_id and fts_vector)
  return data.map((flashcard) => ({
    id: flashcard.id,
    generation_id: flashcard.generation_id,
    front: flashcard.front,
    back: flashcard.back,
    source: flashcard.source,
    created_at: flashcard.created_at,
    updated_at: flashcard.updated_at,
  })) as FlashcardDto[];
}
```

### Step 4: Implement API Route Handler
In `src/pages/api/flashcards/batch.ts`, implement the `POST` handler:

```typescript
import type { APIContext } from 'astro';
import { z } from 'zod';
import type { CreateFlashcardsBatchCommand } from 'src/types';
import { createBatch } from 'src/lib/services/flashcardService';

export const prerender = false;

const createFlashcardsBatchSchema = z.object({
  generation_id: z.number().int().positive('generation_id must be a positive integer'),
  flashcards: z
    .array(
      z.object({
        front: z.string().min(1).max(200),
        back: z.string().min(1).max(500),
        source: z.enum(['ai-full', 'ai-edited', 'manual']),
      })
    )
    .min(1, 'flashcards must contain at least one item')
    .max(100, 'flashcards cannot contain more than 100 items'),
});

export async function POST(context: APIContext) {
  try {
    // Verify authentication
    const { session, supabase } = context.locals;

    if (!session) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const userId = session.user.id;

    // Parse and validate request body
    let body: unknown;
    try {
      body = await context.request.json();
    } catch {
      return new Response(
        JSON.stringify({ error: 'Invalid JSON in request body' }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    const validationResult = createFlashcardsBatchSchema.safeParse(body);

    if (!validationResult.success) {
      const errors = validationResult.error.errors.map((err) => ({
        path: err.path.join('.'),
        message: err.message,
      }));

      return new Response(
        JSON.stringify({
          error: 'Validation failed',
          details: errors,
        }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    const { generation_id, flashcards } = validationResult.data;

    // Verify that the generation belongs to the user
    const { data: generation, error: generationError } = await supabase
      .from('generations')
      .select('id')
      .eq('id', generation_id)
      .eq('user_id', userId)
      .single();

    if (generationError || !generation) {
      return new Response(
        JSON.stringify({
          error: 'Generation not found or access denied',
        }),
        {
          status: 403,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Create flashcards via service
    const createdFlashcards = await createBatch(
      supabase,
      userId,
      generation_id,
      flashcards
    );

    return new Response(JSON.stringify(createdFlashcards), {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    // Log error for debugging
    console.error('Error in POST /api/flashcards/batch:', error);

    return new Response(
      JSON.stringify({
        error: 'An internal server error occurred. Please try again later.',
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
}
```

### Step 5: Test the Implementation
1. **Unit Tests**: Test the `createBatch` service function with various inputs (success cases, error cases).
2. **Integration Tests**: Test the API endpoint with valid and invalid request bodies, including authentication scenarios.
3. **Manual Testing**: Use Postman or curl to test the endpoint with real data.

### Step 6: Update Documentation
- Update the project's API documentation to include the new endpoint.
- Document the request/response schema for client developers.
- Include examples of successful and error responses.

### Step 7: Monitor and Optimize
- Monitor the endpoint's performance in production.
- Log usage patterns to identify optimization opportunities.
- Set up alerts for error rates exceeding normal thresholds.
