<api_analysis>
### 1. Main Entities from Database Schema

1.  **Users (`auth.users`)**: Stores user authentication data. This table is managed by Supabase Auth. [cite: db-plan.md, "Tabela `auth.users`\nPrzechowuje dane uwierzytelniające użytkowników. **Tabela ta jest tworzona i zarządzana automatycznie przez usługę Supabase Auth.**"]
2.  **Flashcards (`flashcards`)**: Stores individual flashcards for all users. It has foreign keys to `auth.users` and `generations`. [cite: db-plan.md, "Tabela `flashcards`\nPrzechowuje wszystkie fiszki użytkowników."]
3.  **Generations (`generations`)**: Logs each AI flashcard generation session. It has a foreign key to `auth.users`. [cite: db-plan.md, "Tabela `generations`\nLoguje każdą sesję generowania fiszek przez AI."]
4.  **Generation Error Logs (`generation_error_logs`)**: Records errors that occurred during the AI generation process. It has a foreign key to `auth.users`. [cite: db-plan.md, "Tabela `generation_error_logs`\nRejestruje błędy, które wystąpiły podczas generowania fiszek."]

### 2. Key Business Logic Features from PRD

1.  **User Management**: Registration, login, and password changes. [cite: PRD.md, "3.1. Zarządzanie kontem użytkownika: Prosty system oparty na loginie i haśle. Obejmuje rejestrację, logowanie i możliwość zmiany hasła."]
2.  **AI Flashcard Generation**: User submits a block of text, and the system generates a set of flashcard suggestions. [cite: PRD.md, "3.2. Generowanie fiszek przez AI: Użytkownik może wkleić tekst (od 1 000 do 10 000 znaków), z którego system automatycznie wygeneruje zestaw fiszek w formacie przód-tył."]
3.  **Flashcard Review Process**: After generation, the user can review, edit, accept, or reject each suggested flashcard before saving them to their collection. [cite: PRD.md, "3.3. Proces recenzji i kuracji fiszek: Po wygenerowaniu, użytkownik otrzymuje listę sugerowanych fiszek. Każdą z nich może indywidualnie zaakceptować, edytować lub odrzucić."]
4.  **Manual Flashcard Management (CRUD)**: Users can manually create, view, search, edit, and delete their flashcards. [cite: PRD.md, "3.4. Ręczne tworzenie fiszek", "3.5. Zarządzanie kolekcją fiszek"]
5.  **Spaced Repetition Session**: Users can start a study session where flashcards are presented based on a spaced repetition algorithm. [cite: PRD.md, "3.6. Integracja z systemem powtórek", "US-012: Rozpoczęcie sesji powtórkowej"]
6.  **System Event Logging**: The system must log generation events and the outcome of the review process to measure success metrics. [cite: PRD.md, "3.7. Logowanie zdarzeń systemowych", "US-013: Logowanie zdarzeń na potrzeby metryk"]

### 3. Mapping PRD Features to API Endpoints

#### Feature: AI Flashcard Generation (US-004)
*   **Description**: A user submits text to generate flashcards. This is a business process, not a simple CRUD operation. It involves calling an external AI service and logging the attempt.
*   **Option A**: `POST /flashcards/generate`
    *   *Pros*: The endpoint name is very explicit about its action.
    *   *Cons*: It operates on the `flashcards` resource but doesn't directly create flashcards; it creates *suggestions*. It also doesn't align well with the `generations` table which is the primary record of this action.
*   **Option B**: `POST /generations`
    *   *Pros*: This is more RESTful. It creates a new `generation` resource. The request body contains the source text. The response body can contain the list of suggested flashcards generated by the AI. This endpoint's logic can handle creating the `generations` log entry, calling the AI, and returning the result.
    *   *Cons*: The name is less intuitive to someone unfamiliar with the database schema.
*   **Decision**: **Option B (`POST /generations`)** is chosen. It correctly models the operation as the creation of a "generation session" resource, which aligns perfectly with the database schema and business logging requirements.

#### Feature: Save Reviewed Flashcards to Collection (US-005)
*   **Description**: After the user reviews (accepts, edits) the AI-generated suggestions on the frontend, they save the final set to their collection. This involves creating multiple flashcard records at once.
*   **Option A**: `POST /generations/{id}/commit`
    *   *Pros*: Links the action directly to the generation session.
    *   *Cons*: This is an RPC-style (Remote Procedure Call) endpoint, not very RESTful. The state (the list of cards to save) would have to be sent in the body, making the `{id}` somewhat redundant.
*   **Option B**: `POST /flashcards/batch`
    *   *Pros*: This is a more resource-oriented approach. The client is asking to create a batch of `flashcard` resources. The request body would be an array of flashcard objects. Each object can contain the `generation_id` to link it back to the source session, fulfilling the logging requirement. This single endpoint can be used to save flashcards from both AI generation and potentially other future batch-creation features.
    *   *Cons*: None, this is a clean and extensible approach.
*   **Decision**: **Option B (`POST /flashcards/batch`)** is chosen. It's a clean, RESTful way to handle the creation of multiple resources at once and aligns with the `flashcards` resource.

#### Feature: Spaced Repetition Session (US-012)
*   **Description**: The user wants to start a study session, which requires fetching the flashcards due for review today.
*   **Option A**: `GET /flashcards?due=today`
    *   *Pros*: Simple filtering on the main `flashcards` resource.
    *   *Cons*: The logic for determining "due" cards might be complex and is owned by the spaced repetition algorithm, not the flashcard entity itself. Mixing this logic into the generic `/flashcards` endpoint could complicate it.
*   **Option B**: `GET /study-session/today` or `GET /reviews`
    *   *Pros*: Creates a dedicated resource (`study-session` or `reviews`) that represents the business concept of a study session. The logic for fetching the correct cards is encapsulated within this endpoint, keeping the `/flashcards` endpoint clean for simple CRUD.
    *   *Cons*: Introduces a new top-level resource that doesn't directly map to a database table.
*   **Decision**: **Option B (`GET /reviews`)** is chosen. It represents a clearer separation of concerns. The `/reviews` endpoint is responsible for providing the data needed for a review session, which is a core business process.

### 4. Security and Performance Requirements

1.  **Authentication**: All endpoints (except for login/register) must be authenticated. The tech stack specifies Supabase, which uses JWTs. [cite: tech-stack.md, "Posiada wbudowaną autentykację użytkowników"]
2.  **Authorization (Data Isolation)**: Users must only be able to access and manipulate their own data. This is explicitly required by the PRD and implemented via PostgreSQL RLS in the database plan. The API must operate within this security context. [cite: PRD.md, "Wdrożone zostaną podstawowe mechanizmy bezpieczeństwa, w tym... Row-Level Security (RLS) w bazie danych, aby zapewnić izolację danych użytkowników."; db-plan.md, "Zdefiniowane polityki zapewniają, że użytkownicy mogą wykonywać wszystkie operacje (`SELECT`, `INSERT`, `UPDATE`, `DELETE`) wyłącznie na swoich własnych danych"]
3.  **Performance (Searching)**: The application requires efficient full-text search on flashcards. The database schema supports this with a GIN index on a `tsvector` column. The API must expose a parameter to leverage this. [cite: db-plan.md, "Indeks GIN (dla wydajnego wyszukiwania pełnotekstowego): Na kolumnie `fts_vector` w tabeli `flashcards`.", PRD.md, "Zaawansowane wyszukiwanie fiszek po slowach kluczowych."]
4.  **Performance (Listing)**: For endpoints that return lists (e.g., `GET /flashcards`), pagination is essential to handle large collections of flashcards efficiently.

### 5. Mapping Business Logic to API Endpoints

| PRD User Story / Requirement                                     | Mapped API Endpoint(s)                                                                  |
| :----------------------------------------------------------------- | :-------------------------------------------------------------------------------------- |
| US-001, US-002, US-003 (User Account Management)                    | Handled by Supabase Auth SDK on the client-side (e.g., `supabase.auth.signUp()`)        |
| US-004 (Generate flashcards from text)                             | `POST /generations`                                                                     |
| US-005 (Review and save generated flashcards)                      | `POST /flashcards/batch`                                                                |
| US-006 (Manual flashcard creation)                                 | `POST /flashcards`                                                                      |
| US-007, US-009 (Browse and search flashcards)                       | `GET /flashcards` (with pagination and search query parameters)                         |
| US-010 (Edit an existing flashcard)                                | `PUT /flashcards/{id}` or `PATCH /flashcards/{id}`                                      |
| US-011 (Delete a flashcard)                                        | `DELETE /flashcards/{id}`                                                               |
| US-012 (Start a repetition session)                                | `GET /reviews`                                                                          |
| US-013, 6.1, 6.2 (Metric Logging)                                  | Internal logic within `POST /generations`, `POST /flashcards`, `POST /flashcards/batch` |

### 6. Validation Conditions in API Plan

The API will enforce validation based on the database schema constraints:

*   For `POST /generations`:
    *   `source_text_length`: Must be between 1000 and 10000 characters. [cite: db-plan.md, "ograniczenie `CHECK` (`source_text_length` BETWEEN 1000 AND 10000)"]
*   For `POST /flashcards` and `POST /flashcards/batch`:
    *   `front`: Required (`NOT NULL`), max length 200. [cite: db-plan.md, "`VARCHAR(200)`, `NOT NULL`"]
    *   `back`: Required (`NOT NULL`), max length 500. [cite: db-plan.md, "`VARCHAR(500)`, `NOT NULL`"]
    *   `source`: Required (`NOT NULL`), must be one of 'ai-full', 'ai-edited', 'manual'. [cite: db-plan.md, "ograniczenie `CHECK` (wartości: 'ai-full', 'ai-edited', 'manual')"]
*   For all requests, the `user_id` will be derived from the JWT token and does not need to be provided in the request body, ensuring users can only operate on their own data.

</api_analysis>

# REST API Plan

## 1. Resources

-   **Flashcards**: Represents user-created flashcards. Maps to the `flashcards` table.
-   **Generations**: Represents an AI-powered flashcard generation session. Maps to the `generations` table.
-   **Reviews**: Represents a collection of flashcards due for a study session. This is a computed resource, not a direct table mapping.

## 2. Endpoints

### Flashcards Resource

---

#### `GET /flashcards`

-   **Description**: Retrieves a paginated list of the authenticated user's flashcards. Supports filtering and full-text search.
-   **Query Parameters**:
    -   `page` (integer, optional, default: 1): The page number for pagination.
    -   `pageSize` (integer, optional, default: 20): The number of items per page.
    -   `search` (string, optional): A search term for full-text search across the `front` and `back` of flashcards.
-   **Success Response**:
    -   **Code**: `200 OK`
    -   **Payload**:
        ```json
        {
          "data": [
            {
              "id": "1",
              "front": "What is REST?",
              "back": "Representational State Transfer is an architectural style for designing networked applications.",
              "source": "manual",
              "created_at": "2025-11-01T10:00:00Z",
              "updated_at": "2025-11-01T10:00:00Z"
            }
          ],
          "pagination": {
            "page": 1,
            "pageSize": 20,
            "totalItems": 1,
            "totalPages": 1
          }
        }
        ```
-   **Error Responses**:
    -   **Code**: `401 Unauthorized`

---

#### Get a Single Flashcard

-   **Method**: `GET`
-   **URL**: `/flashcards/{id}`
-   **Description**: Retrieves a single flashcard by its ID.
-   **Request Payload**: None
-   **Response Payload**:
    ```json
    {
      "id": "1",
      "front": "What is REST?",
      "back": "Representational State Transfer is an architectural style for designing networked applications.",
      "source": "manual",
      "created_at": "2025-11-02T10:00:00Z",
      "updated_at": "2025-11-02T10:00:00Z"
    }
    ```
-   **Success Codes**:
    -   `200 OK`: Successfully retrieved the flashcard.
-   **Error Codes**:
    -   `401 Unauthorized`: User is not authenticated.
    -   `404 Not Found`: No flashcard with the given ID exists for the user.

---

#### `POST /flashcards`

-   **Description**: Creates a new, single flashcard manually.
-   **Request Payload**:
    ```json
    {
      "front": "What is the capital of Poland?",
      "back": "Warsaw"
    }
    ```
-   **Response**:
    -   **Code**: `201 Created`
    -   **Payload**: The newly created flashcard object.
        ```json
        {
          "id": "2",
          "user_id": "user-uuid-from-jwt",
          "generation_id": null,
          "front": "What is the capital of Poland?",
          "back": "Warsaw",
          "source": "manual",
          "created_at": "2025-11-02T18:00:00Z",
          "updated_at": "2025-11-02T18:00:00Z"
        }
        ```
-   **Error Responses**:
    -   **Code**: `400 Bad Request` (e.g., missing `front` or `back`, fields exceed length limits).
    -   **Code**: `401 Unauthorized`

---

#### `POST /flashcards/batch`

-   **Description**: Creates multiple flashcards at once. Used after a user reviews AI-generated suggestions.
-   **Request Payload**:
    ```json
    {
      "generation_id": "123",
      "flashcards": [
        {
          "front": "First AI-generated question",
          "back": "First answer.",
          "source": "ai-full" 
        },
        {
          "front": "Edited AI question",
          "back": "Edited answer.",
          "source": "ai-edited"
        }
      ]
    }
    ```
-   **Response**:
    -   **Code**: `201 Created`
    -   **Payload**: An array of the newly created flashcard objects.
-   **Error Responses**:
    -   **Code**: `400 Bad Request` (Invalid payload structure or validation fails for one of the flashcards).
    -   **Code**: `401 Unauthorized`

---

#### `PUT /flashcards/{id}`

-   **Description**: Updates an existing flashcard.
-   **Request Payload**:
    ```json
    {
      "front": "An updated question",
      "back": "An updated answer"
    }
    ```
-   **Response**:
    -   **Code**: `200 OK`
    -   **Payload**: The complete, updated flashcard object.
-   **Error Responses**:
    -   **Code**: `400 Bad Request`
    -   **Code**: `401 Unauthorized`
    -   **Code**: `403 Forbidden` (User does not own this flashcard).
    -   **Code**: `404 Not Found`

---

#### `DELETE /flashcards/{id}`

-   **Description**: Deletes a specific flashcard.
-   **Response**:
    -   **Code**: `204 No Content`
-   **Error Responses**:
    -   **Code**: `401 Unauthorized`
    -   **Code**: `403 Forbidden`
    -   **Code**: `404 Not Found`

### Generations Resource

---

#### `POST /generations`

-   **Description**: Initiates an AI flashcard generation process from a source text. This is an asynchronous-style call. It creates a `generations` log record and returns the AI-suggested flashcards for client-side review.
-   **Request Payload**:
    ```json
    {
      "source_text": "A long block of text between 1000 and 10000 characters..."
    }
    ```
-   **Response**:
    -   **Code**: `200 OK`
    -   **Payload**:
        ```json
        {
          "generation_id": "123",
          "suggested_flashcards": [
            {
              "front": "Suggested question 1",
              "back": "Suggested answer 1"
            },
            {
              "front": "Suggested question 2",
              "back": "Suggested answer 2"
            }
          ]
        }
        ```
-   **Error Responses**:
    -   **Code**: `400 Bad Request` (`source_text` does not meet length requirements).
    -   **Code**: `401 Unauthorized`
    -   **Code**: `500 Internal Server Error` (AI service fails; an error will be logged in `generation_error_logs`).

### Reviews Resource

---

#### `GET /reviews`

-   **Description**: Retrieves the list of flashcards due for review today according to the spaced repetition algorithm.
-   **Response**:
    -   **Code**: `200 OK`
    -   **Payload**: An array of flashcard objects to be reviewed.
        ```json
        [
          {
            "id": "1",
            "front": "What is REST?",
            "back": "Representational State Transfer..."
          }
        ]
        ```
-   **Error Responses**:
    -   **Code**: `401 Unauthorized`

## 3. Authentication and Authorization

-   **Authentication**: The API will use JWT-based authentication provided by Supabase. The client must include a valid JWT in the `Authorization` header of every request: `Authorization: Bearer <SUPABASE_JWT>`.
-   **Authorization**: Authorization is enforced at the database level using PostgreSQL's Row-Level Security (RLS), as defined in the database plan. API business logic will run under the security context of the authenticated user, ensuring that users can only access or modify their own data (`flashcards`, `generations`, etc.). Any attempt to access another user's data will result in a `404 Not Found` or `403 Forbidden` error.

## 4. Validation and Business Logic

-   **Validation**: The API will validate all incoming request payloads against the constraints defined in the database schema.
    -   `flashcards.front`: Required, max 200 characters.
    -   `flashcards.back`: Required, max 500 characters.
    -   `flashcards.source`: Required, must be one of `'ai-full'`, `'ai-edited'`, `'manual'`.
    -   `generations.source_text`: Must have a length between 1000 and 10000 characters.
-   **Business Logic Implementation**:
    -   **AI Generation**: The `POST /generations` endpoint encapsulates the entire generation logic. It first creates a record in the `generations` table, then calls the external Openrouter.ai service. If the AI call fails, it logs the details in the `generation_error_logs` table before returning an error to the client.
    -   **Metrics Logging**: The backend logic for the `POST /flashcards/batch` endpoint is responsible for updating the counters (`accepted_unedited_count`, `accepted_edited_count`) and the `accepted_at` timestamp in the corresponding `generations` record, based on the `source` field of the incoming flashcards. This ensures that business metrics are logged accurately as a result of user actions.